// linux 内核地址映射模型
// 段页式内存管理，
//    1、通过分段与分页的方式来管理内存。
//    2、段式内存中，每个段存储有段号，页号，页偏移。系统为每一个进程建立一个段表，每一分段对应一张页表，段表有一个，对于于多个页表。
//       在进行地址变换时，需要经过三次访问主存。
//
// 32位linux系统0—3G为用户空间，3-4G为内核空间。采用物理地址与逻辑地址一一对应的关系时，当系统内存有8g时，内核空间只能访问1g的地址，剩余的7g地址将得不到访问。
// 怎样解决内核地址访问物理内存空间容量不足的问题？
// 对剩余的7g地址进行划分，一部分用来做内存映射，另一部分用来做映射的具体地址。这样内核访问地址容量不足时，可以通过内存映射访问剩余的空间。
// 这便是linux的高端内存思想。在linux中内核空间分成3类：ZONE_DMA（1—16MB），ZONE_NORMAL（16-896MB），ZONE_HIGHMEM（896M~结束）
// 一个进程运行时，需要使用超过内核空间的地址，linux内核会在ZONE_HIGHMEM上建立一张临时的映射表，映射所需要的内存，当程序运行结束后，释放该内存。
// 这样就解决的内存地址空间不足的问题。虽然他产生类效率的问题，但解决的内存正常访问物理地址的问题。
// 用户空间和系统空间切换，系统在调用时，会将参数写入到寄存器，然后在进入系统空间，以及系统空间押入用户空间的堆栈当中。
// 所以每一个进程都有4GB的地址空间。用户在进入系统空间时，会发生堆栈的改变。
// 因此linux内核由系统内的所有进程共享。
//
// 进程，线程，协程
// 进程系统最小的运行单元，包括文本区域（存储执行的代码），数据区域（变量，程序执行的动态内存）和堆栈区域（活动过程中的调用指令）
// 线程是进程运行的最小单元。一个进程可以有多个线程。线程不基本不拥有系统资源，可并发，共享同一进程的资源。线程间的通信不必调用内核。
// 协程相比较线程，是更为轻便的。它有用户自行管理，自行调度。协程失去了使用多cpu的性能。
//
//
// 进程间通信
// 1、信号 由于所有程序共享内核空间，信号便是通过内核代理进行进程间通信的。P2进程向P1发生信号后，内核接收到信号，将它放到P1的信号队列中，当P1再次进入内核态时，会检查信号队列。并调用相应的信号处理函数。
//    所以，当进程进入内核态发现信号时，会返回用户态，调用信号处理函数。然后再回到内核态。
// 2、共享内存 两个不想干的程序同时访问一个逻辑内存。
// 3、管道
// 4、消息队列
//
// IO多路复用
// 1、select 遍历所有的fd，当找到能读出数据的流时，对他们进行操作。
//      在有大量的读/写fd情况下，select轮训效率低。
//      能监听的端口数量有限
//      需要委会一个fd的数据结构，当fd数量很大情况下，在内核空间和用户空间复制该结构时开销很大
// 2、poll 和select差不多，它没有最大连接数的限制，原因是它采用链表进行存储。
// 3、epoll 采用事件驱动，epoll通过内核和用户空间共享一块内存来实现的。
//      在链接数少的情况下，使用select更好，因为epoll的通知机制需要很多大回调函数。
//
// redis一致性
// 1、设置有效时间，当改数据类型经常变化时，可以采用
// 2、先删除缓存，在更新数据库。保证了缓存和数据库的一致————假如有其他线程，没查到缓存查DB，最后写入DB，缓存与数据库不一致。
// 3、高并发情况下，使用消息队列，需要更新数据时，放到队列中处理，查询时等待前面的更新完成后，在进行查询。
// 4、串行化，读写服务在同一个链接内进行
//


// InventoryID is an option to set bucket inventory id parameter
func InventoryID(value string) Option {
	return addParam("id", value)
}

// ContinuationToken an option to list bucket inventory ContinuationToken parameter
func ContinuationToken(value string) Option {
	return addParam("continuation-token", value)
}
